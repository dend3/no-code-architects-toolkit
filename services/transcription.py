import os
from faster_whisper import WhisperModel
import srt
from datetime import timedelta
from services.file_management import download_file
import logging
import uuid

# Set up logging
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

# Set the default local storage directory
STORAGE_PATH = "/tmp/"

def process_transcription(media_url, output_type, max_chars=56, language=None):
    """Transcribe media and return the transcript, SRT or ASS file path."""
    logger.info(f"Starting transcription for media URL: {media_url} with output type: {output_type}")
    input_filename = download_file(media_url, os.path.join(STORAGE_PATH, 'input_media'))
    logger.info(f"Downloaded media to local file: {input_filename}")

    try:
        # Load model with optimized settings for ARM
        model_size = "base"
        model = WhisperModel(model_size, device="cpu", compute_type="int8", num_workers=2)
        logger.info(f"Loaded faster-whisper {model_size} model")

        # Configure transcription options
        beam_size = 3  # Reduced beam size for faster processing
        language = language if language else None
        
        # Transcribe with optimized settings
        segments, info = model.transcribe(
            input_filename,
            beam_size=beam_size,
            language=language,
            word_timestamps=True,
            condition_on_previous_text=False,  # Disable for faster processing
            vad_filter=True  # Enable voice activity detection for better accuracy
        )
        
        logger.info(f"Transcription completed with language: {info.language}")

        # Process based on output type
        if output_type == "text":
            text = " ".join([segment.text for segment in segments])
            return text, None

        elif output_type == "srt":
            srt_filename = os.path.join(STORAGE_PATH, f"{uuid.uuid4()}.srt")
            with open(srt_filename, "w", encoding="utf-8") as srt_file:
                for i, segment in enumerate(segments, start=1):
                    start = timedelta(seconds=float(segment.start))
                    end = timedelta(seconds=float(segment.end))
                    text = segment.text.strip()
                    
                    srt_file.write(
                        f"{i}\n"
                        f"{str(start).rstrip('0').replace('.', ',')}"
                        f" --> "
                        f"{str(end).rstrip('0').replace('.', ',')}\n"
                        f"{text}\n\n"
                    )
            return None, srt_filename

        elif output_type == "ass":
            ass_filename = os.path.join(STORAGE_PATH, f"{uuid.uuid4()}.ass")
            with open(ass_filename, "w", encoding="utf-8") as ass_file:
                ass_file.write(generate_ass_subtitle(segments, max_chars))
            return None, ass_filename

        else:
            raise ValueError(f"Unsupported output type: {output_type}")

    except Exception as e:
        logger.error(f"Error during transcription: {str(e)}")
        raise

def generate_ass_subtitle(segments, max_chars):
    """Generate ASS subtitle content with highlighted current words."""
    ass_header = """[Script Info]
Title: Auto-generated by NCAT
ScriptType: v4.00+
Collisions: Normal
PlayResX: 1920
PlayResY: 1080

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,54,&H00FFFFFF,&H0000FFFF,&H00000000,&H80000000,-1,0,0,0,100,100,0,0,1,2,3,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"""
    
    ass_content = [ass_header]
    
    for segment in segments:
        start_time = format_ass_time(float(segment.start))
        end_time = format_ass_time(float(segment.end))
        text = segment.text.strip()
        
        # Split long lines
        if len(text) > max_chars:
            words = text.split()
            lines = []
            current_line = []
            current_length = 0
            
            for word in words:
                if current_length + len(word) + 1 <= max_chars:
                    current_line.append(word)
                    current_length += len(word) + 1
                else:
                    lines.append(" ".join(current_line))
                    current_line = [word]
                    current_length = len(word)
            
            if current_line:
                lines.append(" ".join(current_line))
            
            text = "\\N".join(lines)
        
        ass_line = f"Dialogue: 0,{start_time},{end_time},Default,,0,0,0,,{text}\n"
        ass_content.append(ass_line)
    
    return "".join(ass_content)

def format_ass_time(seconds):
    """Convert seconds to ASS time format (H:MM:SS.cc)."""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    seconds = seconds % 60
    centiseconds = int((seconds % 1) * 100)
    seconds = int(seconds)
    return f"{hours}:{minutes:02d}:{seconds:02d}.{centiseconds:02d}"